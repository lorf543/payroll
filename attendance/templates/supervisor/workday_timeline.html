{% extends "base.html" %}
{% load static %}
{% load humanize %}

{% block content %}
<div class="container py-4">
  <div class="d-flex justify-content-between align-items-center mb-4">
    <h2>Session Editor - {{ workday.employee.user.get_full_name }}</h2>
    <div>
      <button type="button" class="btn btn-info me-2" data-bs-toggle="modal" data-bs-target="#adjustmentHistoryModal">
        <i class="bi bi-clock-history"></i> Adjustment History
      </button>
      <a href="{{ referer }}" class="btn btn-outline-secondary">← Go Back</a>
    </div>
  </div>

  <!-- Workday Info -->
  <div class="row mb-4">
    <div class="col-md-8">
      <div class="card">
        <div class="card-body">
          <div class="row">
            <div class="col-md-6">
              <p><strong>Date:</strong> {{ workday.date }}</p>
              <p><strong>Employee:</strong> {{ workday.employee.user.get_full_name }}</p>
            </div>
            <div class="col-md-6">
              <p><strong>Status:</strong> <span class="badge bg-{% if workday.status == 'completed' %}success{% else %}warning{% endif %}">{{ workday.get_status_display }}</span></p>
              {% if workday.last_adjustment_date %}
              <p><strong>Last Adjusted:</strong> {{ workday.last_adjustment_date|naturaltime }} by {{ workday.last_adjusted_by.get_full_name|default:workday.last_adjusted_by.username }}</p>
              {% endif %}
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Summary Cards -->
  <div class="row mb-4">
    <div class="col-md-3">
      <div class="card border-success shadow-sm">
        <div class="card-body text-center">
          <h5 class="card-title text-success mb-2">Total Work</h5>
          <h3 id="totalWorkTime">{{ workday.formatted_work_time }}</h3>
          <small class="text-muted" id="totalWorkMinutes">{{ workday.total_work_minutes }} min</small>
        </div>
      </div>
    </div>
    <div class="col-md-3">
      <div class="card border-warning shadow-sm">
        <div class="card-body text-center">
          <h5 class="card-title text-warning mb-2">Total Lunch</h5>
          <h3 id="totalLunchTime">{{ workday.total_lunch_time|naturaltime }}</h3>
          <small class="text-muted">{{ workday.total_lunch_minutes }} min</small>
        </div>
      </div>
    </div>
    <div class="col-md-3">
      <div class="card border-info shadow-sm">
        <div class="card-body text-center">
          <h5 class="card-title text-info mb-2">Total Breaks</h5>
          <h3 id="totalBreakTime">{{ workday.formatted_break_time }}</h3>
          <small class="text-muted" id="totalBreakMinutes">{{ workday.total_break_minutes }} min</small>
        </div>
      </div>
    </div>
    <div class="col-md-3">
      <div class="card border-secondary shadow-sm">
        <div class="card-body text-center">
          <h5 class="card-title text-secondary mb-2">Adjustments</h5>
          <h3>{{ workday.adjustment_count }}</h3>
          <small class="text-muted">Total adjustments</small>
        </div>
      </div>
    </div>
  </div>

  <!-- Adjustment Reason Modal -->
  <div class="modal fade" id="adjustmentReasonModal" tabindex="-1">
    <div class="modal-dialog">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title">Adjustment Reason</h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
        </div>
        <div class="modal-body">
          <p>Please provide a reason for this time adjustment:</p>
          <textarea id="adjustmentReasonText" class="form-control" rows="4" 
                    placeholder="Example: Corrected lunch time based on team meeting schedule..."></textarea>
          <div class="form-text">
            This reason will be recorded in the adjustment history for audit purposes.
          </div>
        </div>
        <div class="modal-footer">
          <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
          <button type="button" class="btn btn-primary" id="confirmAdjustment">Confirm Adjustment</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Adjustment History Modal -->
  <div class="modal fade" id="adjustmentHistoryModal" tabindex="-1">
    <div class="modal-dialog modal-lg">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title">Adjustment History - {{ workday.date }}</h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
        </div>
        <div class="modal-body">
          {% if workday.adjustment_history %}
            <div class="timeline">
              {% for adjustment in workday.adjustment_history reversed %}
              <div class="timeline-item mb-3">
                <div class="card">
                  <div class="card-body">
                    <div class="d-flex justify-content-between">
                      <h6 class="card-title">{{ adjustment.adjusted_by }}</h6>
                      <small class="text-muted">{{ adjustment.timestamp|slice:":16" }}</small>
                    </div>
                    {% if adjustment.reason %}
                    <p class="card-text">{{ adjustment.reason }}</p>
                    {% endif %}
                    <small class="text-muted">
                      Sessions affected: {{ adjustment.sessions_affected|length }}
                    </small>
                  </div>
                </div>
              </div>
              {% endfor %}
            </div>
          {% else %}
            <p class="text-muted text-center">No adjustments recorded</p>
          {% endif %}
        </div>
      </div>
    </div>
  </div>

  <!-- Sessions Timeline -->
  <div id="timeline-container" class="row gy-3">
    {% for session in sessions %}
      <div class="col-12">
        <div class="card shadow-sm border-session-{{ session.session_type }}">
          <div class="card-body">
            <div class="d-flex justify-content-between align-items-center mb-2">
              <span>
                <strong class="session-label-{{ session.session_type }}">
                  {{ session.get_session_type_display }}
                  {% if session.campaign %} - {{ session.campaign.name }}{% endif %}
                </strong>
                {% if session.is_adjusted %}
                  <span class="badge bg-warning text-dark ms-2" title="Adjusted">
                    <i class="bi bi-pencil"></i> Adjusted
                  </span>
                {% endif %}
              </span>
              <span>
                <span id="time-label-{{ session.id }}" class="text-muted">
                  {{ session.start_time|time:"H:i" }} - {{ session.end_time|time:"H:i" }}
                </span>
                <span id="duration-label-{{ session.id }}" class="badge bg-secondary ms-2">
                  {{ session.duration_minutes }} min
                </span>
              </span>
            </div>
            
            {% if session.adjustment_notes %}
            <div class="alert alert-info py-2 mb-3">
              <small><strong>Adjustment Note:</strong> {{ session.adjustment_notes }}</small>
            </div>
            {% endif %}
            
            <div id="slider-outer-{{ session.id }}"></div>
          </div>
        </div>
      </div>
    {% endfor %}
  </div>
</div>

<!-- JS Global Variables -->
<script>
// JS Global Variables
window.SESSIONS_DATA = {{ sessions_json|safe }};
window.CSRF_TOKEN = "{{ csrf_token }}";
window.UPDATE_SESSION_URL = "{% url 'update_session' 0 %}";

// Global variables for pending adjustment
let pendingSessionId = null;
let pendingStartTime = null;
let pendingEndTime = null;
let sliders = {};

document.addEventListener("DOMContentLoaded", () => {
    const sessions = window.SESSIONS_DATA || [];
    const csrfToken = window.CSRF_TOKEN;

    // Function to create pips (time marks)
    function createPipsFilter() {
        return (value, type) => {
            const hours = Math.floor(value / 60);
            const minutes = value % 60;
            
            // Show every hour as major pip
            if (type === 0) { // Major pips
                return minutes === 0 ? 1 : -1;
            }
            // Show 30-minute intervals as minor pips
            if (type === 1) { // Minor pips  
                return minutes === 30 ? 2 : -1;
            }
            return -1;
        };
    }

    // Function to format pip labels
    function formatPipLabel(value) {
        const hours = Math.floor(value / 60);
        const minutes = value % 60;
        if (minutes === 0) {
            return `${hours}:00`;
        }
        return `${hours}:${minutes}`;
    }

    // Initialize all sliders
    sessions.forEach((session, index) => {
        const container = document.getElementById(`slider-outer-${session.id}`);
        if (!container) return;

        const startMinutes = toMinutes(session.start);
        const endMinutes = toMinutes(session.end);

        // Create manual input container
        const inputContainer = document.createElement("div");
        inputContainer.className = "manual-inputs mb-3";
        inputContainer.innerHTML = `
            <div class="row g-2 align-items-center">
                <div class="col-auto">
                    <label class="form-label small mb-1">Start Time</label>
                    <input type="time" 
                         id="start-input-${session.id}" 
                         class="form-control form-control-sm time-input" 
                         value="${session.start}"
                         data-session-id="${session.id}">
                </div>
                <div class="col-auto">
                    <label class="form-label small mb-1">End Time</label>
                    <input type="time" 
                         id="end-input-${session.id}" 
                         class="form-control form-control-sm time-input" 
                         value="${session.end}"
                         data-session-id="${session.id}">
                </div>
                <div class="col-auto">
                    <button type="button" 
                         class="btn btn-primary btn-sm mt-3 update-time-btn" 
                         data-session-id="${session.id}">
                        Update
                    </button>
                </div>
            </div>
        `;

        // Create slider container
        const slider = document.createElement("div");
        slider.className = "session-slider";

        // Insert elements in order
        container.appendChild(inputContainer);
        container.appendChild(slider);

        noUiSlider.create(slider, {
            start: [startMinutes, endMinutes],
            connect: true,
            step: 1, // 1 minute precision
            range: { min: 0, max: 24 * 60 },
            tooltips: [
                { to: v => minutesToTime(v), from: v => toMinutes(v) },
                { to: v => minutesToTime(v), from: v => toMinutes(v) }
            ],
            format: {
                to: v => Math.round(v),
                from: v => Number(v)
            },
            // Add pips (time marks)
            pips: {
                mode: 'values',
                values: [0, 120, 240, 360, 480, 600, 720, 840, 960, 1080, 1200, 1320, 1440], // Every 2 hours
                density: 12,
                format: {
                    to: formatPipLabel
                }
            }
        });

        // Guardar referencia al slider
        sliders[session.id] = slider;

        // Event listeners for manual inputs
        const startInput = document.getElementById(`start-input-${session.id}`);
        const endInput = document.getElementById(`end-input-${session.id}`);
        const updateBtn = document.querySelector(`.update-time-btn[data-session-id="${session.id}"]`);

        // Update slider when manual inputs change (optional real-time update)
        [startInput, endInput].forEach(input => {
            input.addEventListener('change', () => {
                const startVal = toMinutes(startInput.value);
                const endVal = toMinutes(endInput.value);
                
                // Validate time range
                if (endVal > startVal) {
                    slider.noUiSlider.set([startVal, endVal]);
                    updateSessionLabels(session.id, startInput.value, endInput.value);
                }
            });
        });

        // Update session when update button is clicked
        updateBtn.addEventListener('click', () => {
            updateSessionFromInputs(session.id);
        });

        // Also update on Enter key in inputs
        [startInput, endInput].forEach(input => {
            input.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    updateSessionFromInputs(session.id);
                }
            });
        });

        // Evento al cambiar el slider
        slider.noUiSlider.on("change", async (values) => {
            const [startMinutes, endMinutes] = values.map(Number);
            const newStart = minutesToTime(startMinutes);
            const newEnd = minutesToTime(endMinutes);

            await updateSessionTime(session.id, newStart, newEnd);
        });

        // Evento mientras se arrastra el slider (feedback visual)
        slider.noUiSlider.on("update", (values) => {
            const [startMinutes, endMinutes] = values.map(Number);
            const newStart = minutesToTime(startMinutes);
            const newEnd = minutesToTime(endMinutes);
            
            // Update manual inputs in real-time while dragging
            if (startInput) startInput.value = newStart;
            if (endInput) endInput.value = newEnd;
            
            updateSessionLabels(session.id, newStart, newEnd);
        });
    });

    // Function to update session from manual inputs
    async function updateSessionFromInputs(sessionId) {
        const startInput = document.getElementById(`start-input-${sessionId}`);
        const endInput = document.getElementById(`end-input-${sessionId}`);
        
        if (!startInput || !endInput) return;

        const newStart = startInput.value;
        const newEnd = endInput.value;

        // Validate time range
        if (toMinutes(newEnd) <= toMinutes(newStart)) {
            Swal.fire({
                icon: "warning",
                title: "Invalid Time Range",
                text: "End time must be after start time",
                timer: 2000,
                showConfirmButton: false
            });
            return;
        }

        await updateSessionTime(sessionId, newStart, newEnd);
    }

    // Modified updateSessionTime function to use modal
    async function updateSessionTime(sessionId, newStart, newEnd) {
        // Store pending adjustment
        pendingSessionId = sessionId;
        pendingStartTime = newStart;
        pendingEndTime = newEnd;
        
        // Show adjustment reason modal instead of immediate update
        const modal = new bootstrap.Modal(document.getElementById('adjustmentReasonModal'));
        
        // Clear previous reason
        document.getElementById('adjustmentReasonText').value = '';
        
        modal.show();
    }

    // Confirm adjustment button handler
    document.getElementById('confirmAdjustment').addEventListener('click', async () => {
        const reasonTextarea = document.getElementById('adjustmentReasonText');
        const adjustmentReason = reasonTextarea.value.trim();
        
        if (!adjustmentReason) {
            Swal.fire({
                icon: 'warning',
                title: 'Reason Required',
                text: 'Please provide a reason for this adjustment',
                timer: 2000
            });
            return;
        }

        // Close modal
        const modal = bootstrap.Modal.getInstance(document.getElementById('adjustmentReasonModal'));
        modal.hide();

        // Show loading
        Swal.fire({
            title: 'Updating sessions...',
            text: 'Adjusting timeline',
            allowOutsideClick: false,
            didOpen: () => { Swal.showLoading(); }
        });

        try {
            const response = await fetch(UPDATE_SESSION_URL.replace('0', pendingSessionId), {
                method: "POST",
                headers: {
                    "X-CSRFToken": csrfToken,
                    "X-Requested-With": "XMLHttpRequest",
                    "Content-Type": "application/x-www-form-urlencoded",
                },
                body: new URLSearchParams({
                    start: pendingStartTime,
                    end: pendingEndTime,
                    adjustment_reason: adjustmentReason
                })
            });

            const data = await response.json();
            
            if (data.success) {
                // Update all affected sessions
                if (data.updated_sessions) {
                    data.updated_sessions.forEach(updatedSession => {
                        updateSessionDisplay(updatedSession);
                    });
                }

                // Update totals
                updateTotals(data.total_work, data.total_breaks, data.total_lunch);

                // Clear the reason textarea
                reasonTextarea.value = '';

                Swal.fire({
                    icon: "success",
                    title: "Sessions Updated!",
                    html: `Timeline adjusted successfully<br>
                          <small class="text-muted">Reason: ${adjustmentReason}</small>`,
                    timer: 2500,
                    showConfirmButton: false
                });
            } else {
                Swal.fire({
                    icon: "error",
                    title: "Error",
                    text: data.message || "Failed to update session"
                });
            }
        } catch (error) {
            console.error('Error:', error);
            Swal.fire({
                icon: "error",
                title: "Network Error",
                text: "Could not update session. Please try again."
            });
        }
    });

    // Función para actualizar la visualización de una sesión
    function updateSessionDisplay(sessionData) {
        const timeLabel = document.getElementById(`time-label-${sessionData.id}`);
        const durationLabel = document.getElementById(`duration-label-${sessionData.id}`);
        const slider = sliders[sessionData.id];
        const startInput = document.getElementById(`start-input-${sessionData.id}`);
        const endInput = document.getElementById(`end-input-${sessionData.id}`);

        if (timeLabel) {
            timeLabel.textContent = `${sessionData.start} - ${sessionData.end}`;
        }
        
        if (durationLabel) {
            durationLabel.textContent = `${sessionData.duration} min`;
        }

        // Update manual inputs
        if (startInput) startInput.value = sessionData.start;
        if (endInput) endInput.value = sessionData.end;

        // Actualizar slider sin disparar eventos
        if (slider) {
            const startMinutes = toMinutes(sessionData.start);
            const endMinutes = toMinutes(sessionData.end);
            slider.noUiSlider.set([startMinutes, endMinutes], false);
        }
    }

    // Update session labels temporarily (while dragging)
    function updateSessionLabels(sessionId, startTime, endTime) {
        const timeLabel = document.getElementById(`time-label-${sessionId}`);
        const durationLabel = document.getElementById(`duration-label-${sessionId}`);
        const duration = toMinutes(endTime) - toMinutes(startTime);
        
        if (timeLabel) {
            timeLabel.textContent = `${startTime} - ${endTime}`;
        }
        if (durationLabel) {
            durationLabel.textContent = `${duration} min`;
        }
    }

    // Funciones de utilidad
    function toMinutes(timeStr) {
        const [h, m] = timeStr.split(":").map(Number);
        return h * 60 + m;
    }

    function minutesToTime(mins) {
        const totalMinutes = Math.round(mins);
        const h = Math.floor(totalMinutes / 60);
        const m = totalMinutes % 60;
        return `${String(h).padStart(2, "0")}:${String(m).padStart(2, "0")}`;
    }

    function formatMinutesToHours(minutes) {
        const hours = Math.floor(minutes / 60);
        const mins = minutes % 60;
        if (hours > 0) {
            return `${hours}h ${String(mins).padStart(2, "0")}m`;
        }
        return `${mins}m`;
    }

    function updateTotals(workMinutes, breakMinutes, lunchMinutes) {
        // Work time
        const workTimeEl = document.getElementById("totalWorkTime");
        const workMinutesEl = document.getElementById("totalWorkMinutes");
        if (workTimeEl) {
            workTimeEl.textContent = formatMinutesToHours(workMinutes);
        }
        if (workMinutesEl) {
            workMinutesEl.textContent = workMinutes;
        }

        // Break time
        const breakTimeEl = document.getElementById("totalBreakTime");
        const breakMinutesEl = document.getElementById("totalBreakMinutes");
        if (breakTimeEl) {
            breakTimeEl.textContent = formatMinutesToHours(breakMinutes);
        }
        if (breakMinutesEl) {
            breakMinutesEl.textContent = breakMinutes;
        }

        // Lunch time
        const lunchTimeEl = document.getElementById("totalLunchTime");
        if (lunchTimeEl) {
            lunchTimeEl.textContent = `${lunchMinutes} min`;
        }
    }

    // Handle modal hidden event to reset pending adjustment if user cancels
    document.getElementById('adjustmentReasonModal').addEventListener('hidden.bs.modal', function () {
        // Reset to original values if user cancels without confirming
        if (pendingSessionId && sliders[pendingSessionId]) {
            const originalSession = sessions.find(s => s.id === pendingSessionId);
            if (originalSession) {
                const startInput = document.getElementById(`start-input-${pendingSessionId}`);
                const endInput = document.getElementById(`end-input-${pendingSessionId}`);
                
                if (startInput) startInput.value = originalSession.start;
                if (endInput) endInput.value = originalSession.end;
                
                const startMinutes = toMinutes(originalSession.start);
                const endMinutes = toMinutes(originalSession.end);
                sliders[pendingSessionId].noUiSlider.set([startMinutes, endMinutes]);
                
                updateSessionLabels(pendingSessionId, originalSession.start, originalSession.end);
            }
        }
        
        // Reset pending variables
        pendingSessionId = null;
        pendingStartTime = null;
        pendingEndTime = null;
    });
});

</script>

<!-- Libraries -->
<link href="https://cdn.jsdelivr.net/npm/nouislider@15.7.0/dist/nouislider.min.css" rel="stylesheet">
<link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.0/font/bootstrap-icons.css" rel="stylesheet">
<script src="https://cdn.jsdelivr.net/npm/nouislider@15.7.0/dist/nouislider.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>



{% endblock %}